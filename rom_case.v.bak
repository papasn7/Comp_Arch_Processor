// auto generated from http://users.rowan.edu/~haskellt8/assembler/
module rom_case(out, address);
	output reg [31:0] out;
	input  [15:0] address; // address- 16 deep memory  
	always @(address) begin
		case (address)
			/*//First processor test
			16'h0:  out = 32'b11010010100000000000000000100001; // MOVZ X1, 1
			16'h4:  out = 32'b11010010100000000000000001000010; // MOVZ X2, 2
			16'h8:  out = 32'b10001011000000100000000000100100; // ADD X4, X1, X2
			16'hc:  out = 32'b11111000000010000000001111100100; // STUR X4, [XZR, 128]
			16'h10:  out = 32'b11111000010010000000001111100101; // LDUR X5, [XZR, 128]
			16'h14:  out = 32'b10010100000000000000000000001010; // BL 10
			16'h18:  out = 32'b10110101000000000000000000100010; // CBNZ X2, 1
			16'h1c:  out = 32'b00010100000000000000000000000001; // B 1
			16'h20:  out = 32'b00010111111111111111111111111001; // B -7
			16'h24:  out = 32'b10110100000000000000000001100001; // CBZ X1, 3
			16'h28:  out = 32'b11101011000000100000000000111111; // SUBS XZR, X1, X2
			16'h2c:  out = 32'b01010100000000000000000000100011; // B.LO 1
			16'h30:  out = 32'b11111000000010000100001111100001; // STUR X1, [XZR, 132]
			16'h34:  out = 32'b11111000010010000100001111100110; // LDUR X6, [XZR, 132]
			16'h38:  out = 32'b11010010000000000000010011100111; // EORI X7, X7, 1
			16'h3c:  out = 32'b00010111111111111111111111111110; // B -2
			16'h40:  out = 32'b10010001000000000000100000100001; // ADDI X1, X1, 2
			16'h44:  out = 32'b11010001000000000000010001000010; // SUBI X2, X2, 1
			16'h48:  out = 32'b11010110000000000000001111000000; // BR X30
			default: out=32'hD60003E0; //BR XZR
			*/
			16'h0:  out = 32'b11010010100_0100000101111110_00000; // MOVZ X0, I
			16'h4:  out = 32'b11010010100_0100000100011000_00001; // MOVZ X1, I
			16'h8:  out = 32'b11010010100_0100000100011000_00010; // MOVZ X2, I
			16'hc:  out = 32'b11010010100_0111111100011000_00011; // MOVZ X3, I
			16'h10:  out = 32'b11010010100_0111111100011000_00100; // MOVZ X4, I
			16'h14:  out = 32'b11010010100_0100000100011000_00101; // MOVZ X5, I
			16'h18:  out = 32'b11010010100_0100000100011000_00110; // MOVZ X6, I
			16'h1c:  out = 32'b11010010100_0100000101111110_00111; // MOVZ X7, I
			16'h20:  out = 32'b11111000000100000000001111100000; // STUR X0, [XZR, 256]
			16'h24:  out = 32'b11111000000100010000001111100001; // STUR X1, [XZR, 272]
			16'h28:  out = 32'b11111000000100100000001111100010; // STUR X2, [XZR, 288]
			16'h2c:  out = 32'b11111000000100110000001111100011; // STUR X3, [XZR, 304]
			16'h30:  out = 32'b11111000000101000000001111100100; // STUR X4, [XZR, 320]
			16'h34:  out = 32'b11111000000101010000001111100101; // STUR X5, [XZR, 336]
			16'h38:  out = 32'b11111000000101100000001111100110; // STUR X6, [XZR, 352]
			16'h3c:  out = 32'b11111000000101110000001111100111; // STUR X7, [XZR, 368] 
		endcase
	end
endmodule

/*
C code for above asm:
X1 = 1;
X2 = 2;
while(1) {
	X4 = X1 + X2;
	M[16] = X4;
	X5 = M[16];
	IncDec();
	if(X2 == 0) {
		break;
	}
}
if(X1 != 0) {
	if(X1 > X2) {
		M[8] = X1;
	}
}
X6 = M[8]
while(1){
	X7 = X7 ^ 1;
}

void IncDec(void) {
	X1 = X1 + 1;
	X2 = X2 - 1
}
*/
